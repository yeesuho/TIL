2025.05.28

출처: 강준석 선생님


## 네트워크 (Networks)
### 1. Q: OSI 7계층과 TCP/IP 4계층 모델에 대해 설명해주세요.
A: OSI 7계층은 네트워크 통신 과정을 7개의 추상화된 계층(물리, 데이터 링크, 네
트워크, 전송, 세션, 표현, 응용)으로 나눈 모델입니다. TCP/IP 4계층은 이를 더 단
순화한 모델(네트워크 인터페이스, 인터넷, 전송, 응용)로 실제 인터넷에서 주로 사
용됩니다. (각 계층의 역할 간략히 설명)

### 2. Q: TCP와 UDP의 차이점을 설명해주세요. 어떤 상황에서 각각 사용하는 것이 좋을까요?
A: TCP는 연결 지향형 프로토콜로 신뢰성 있는 데이터 전송을 보장하지만(3-way
handshake, 흐름 제어, 혼잡 제어), 속도가 상대적으로 느립니다. UDP는 비연결
형 프로토콜로 데이터 전송을 보장하지 않지만, 속도가 빠릅니다. 신뢰성이 중요한
데이터(파일 전송, 이메일)에는 TCP, 실시간성이 중요한 데이터(스트리밍, 온라인
게임)에는 UDP가 적합합니다.

### 3. Q: 3-way handshake와 4-way handshake에 대해 설명해주세요.
A: 3-way handshake는 TCP 연결을 설정하는 과정(SYN -> SYN+ACK ->
ACK)이고, 4-way handshake는 TCP 연결을 해제하는 과정(FIN -> ACK ->
FIN -> ACK)입니다. 이를 통해 양단 간의 신뢰성 있는 연결 수립 및 해제가 이루어
집니다.

### 4. Q: HTTP와 HTTPS의 차이점은 무엇인가요?
A: HTTP는 웹에서 클라이언트와 서버 간에 데이터를 주고받는 프로토콜이며, 암
호화되지 않아 보안에 취약합니다. HTTPS는 HTTP에 SSL/TLS 프로토콜을 추가
하여 데이터를 암호화함으로써 보안을 강화한 버전입니다. (SSL/TLS 인증서, 암호
화 방식 간략히 언급)
### 5. Q: DNS(Domain Name System)란 무엇이며, 어떤 역할을 하나요?
A: DNS는 사람이 기억하기 쉬운 도메인 이름(예: www.google.com)을 컴퓨터가
이해할 수 있는 IP 주소로 변환해주는 시스템입니다. 사용자가 도메인 이름을 입력
하면 DNS 서버를 통해 해당 도메인에 매핑된 IP 주소를 찾아 접속할 수 있게 합니
다.

### 6. Q: RESTful API란 무엇이며, REST의 특징(원칙)은 무엇인가요?
A: REST(Representational State Transfer)는 웹 서비스 아키텍처 스타일 중 하
나입니다. RESTful API는 이러한 REST 원칙을 따르는 API를 의미하며, HTTP
URI를 통해 자원(Resource)을 명시하고, HTTP Method(GET, POST, PUT,
DELETE 등)를 통해 해당 자원에 대한 CRUD 연산을 수행합니다. 주요 특징으로는
클라이언트-서버 구조, 무상태성(Stateless), 캐시 가능(Cacheable), 계층화 시스
템(Layered System), 유니폼 인터페이스(Uniform Interface) 등이 있습니다.




<br>
<br>

REST (Representational State Transfer) 아키텍처 스타일이 등장하게 된 배경에는 기존
분산 시스템 아키텍처의 한계점과 월드 와이드 웹(WWW)의 성공적인 확장성을 모델링하려
는 목표가 있었습니다. REST의 창시자인 로이 필딩(Roy Fielding)은 2000년 박사 논문에
서 웹의 아키텍처를 설명하고 이를 일반화하기 위해 REST를 제안했습니다.

REST : 분산 하이퍼미디어(ex 웹)을 위한 아키텍처 스타일. 규칙과 제약조건

REST API : REST 따르는 API / HTTP를 효과적으로 잘 사용하기 위한 규칙.

- 명확한 Client - Server 구조
- 기본적으로 Stateless 한 통신
- 자원의 위치를 기록하는 URI (Uniform Interface)와 HTTP Method의 사용
  
<br>
<br>

![img](/img/OSI%207.png)

### 1계층, 물리계층(Physical Layer)
주로 전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송하는 물리적인 장비이다.<br>
기능 : 데이터 전기적인 신호 0과 1을 변환해서 주고받는다<br>
단위 : 비트(Bit)<br>
장비 : 통신 케이블, 리퍼터, 허브

### 2계층, 데이터 링크계층(DataLink Layer)
물리계층을 통해 송수시되는 정보의 오류와 흐름을 관리하여 안전한 통신의 흐름을 관리한
다.<br>
기능 : 프레임의 물리적 주소(맥 주소, Mac address)를 부여하고 에러검출, 재전송, 흐름제
어를 수행<br>
단위 : 프레임(Frame)<br>
장비 : 브리지, 스위치, 이더넷 등(여기서 맥 주소를 가지고 물리계층에서 받은 정보 전달)


### 3계층, 네트워크 계층(Network Layer)
데이터를 목적지까지 안전하고 빠르게 전달한다.<br>
기능 : 라우터(Router)를 통해 경로를 선택하고 주소를 정하고(IP) 경로(Route)에 따라 패
킷을 전달 => IP 헤더 붙음<br>
단위 : 패킷(Packet)<br>
장비 : 라우터(Router)

### 4계층, 전송 계층(Transport Layer)
port 번호, 전송 방식(TCP/UDP) 결정 => TCP 헤더 붙음.<br>
기능 : 두 지점간의 신뢰성 있는 데이터를 주고 받게 해주며 신호를 분산하고 다시 합치는 과
정을 통해 에러와 경로를 제어<br>

### 5계층, 세션 계층(Session Layer)
기능 : 주 지점간의 프로세스 및 통신하는 호스트 간의 연결 유지<br>
TCP/IP 세션 체결, 포트번호를 기반으로 통신 세션 구성. API, Socket.

### 6계층, 표현 계층(Presentation Layer)
전송하는 데이터의 표현방식을 결정<br>
기능 : 파일인코딩, 명령어를 포장, 압축, 암호화
JPEF, MPEG, GIF, ASCII 등

### 7계층, 응용 계층(Application Layer)
기능 : 최종 목적지로, 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행<br>
HTTP, FTP, SMTP, POP3, IMAP, Telent 등과 같은 프로토콜이 있다.



## 1. 3-way Handshake (TCP 연결 설정 과정)
### 목적:
3-way handshake는 두 장치 간에 신뢰성 있는 TCP 연결을 수립하기 위한 과정입니다.<br>
이 과정을 통해 양쪽 장치는 서로 통신할 준비가 되었음을 확인하고, 초기 순서 번호
(Sequence Number)를 교환하여 데이터 전송의 순서를 보장합니다.

### 과정 (Client가 Server에 연결을 요청하는 경우):
#### 1. SYN (Synchronize Sequence Numbers - 동기화 요청):
- Client → Server: 클라이언트가 서버에 연결을 요청하는 첫 번째 단계입니다.
- 클라이언트는 임의의 초기 순서 번호 ( client_isn )를 설정하고, TCP 헤더의 SYN 플
래그를 1로 설정한 세그먼트(패킷)를 서버로 보냅니다.
- 이때 클라이언트는 SYN_SENT 상태로 들어갑니다.

#### 2. SYN + ACK (Synchronization Acknowledged - 동기화 확인 및 요청):
- Server → Client: 서버가 클라이언트의 SYN 요청을 받고 연결을 수락하는 단계
입니다.
- 서버는 TCP 헤더의 SYN 플래그와 ACK (Acknowledgement) 플래그를 모두 1로
설정한 세그먼트를 클라이언트로 보냅니다.
- 이 세그먼트에는 다음과 같은 정보가 포함됩니다:
    - 서버 자신의 임의의 초기 순서 번호 ( server_isn ).
    - 클라이언트로부터 받은 순서 번호에 1을 더한 값 ( client_isn + 1 )을 확인 번호
(Acknowledgement Number)로 설정하여, 클라이언트의 SYN 을 잘 받았음
을 알립니다.
서버는 SYN_RECEIVED 상태로 들어갑니다.

#### 3. ACK (Acknowledgement - 최종 확인):
- Client → Server: 클라이언트가 서버의 SYN+ACK 세그먼트를 받고, 서버의 연결
요청을 최종적으로 확인하는 단계입니다.
- 클라이언트는 TCP 헤더의 ACK 플래그를 1로 설정한 세그먼트를 서버로 보냅니다.
- 이 세그먼트에는 서버로부터 받은 순서 번호에 1을 더한 값 ( server_isn + 1 )을 확인
번호로 설정하여, 서버의 SYN 을 잘 받았음을 알립니다.
- 이 단계가 완료되면 클라이언트와 서버 모두 ESTABLISHED 상태로 전환되며, 데이터
전송을 시작할 수 있습니다.

> **요약:** Client: SYN (내 번호는 X야, 연결할래?)Server: SYN+ACK (알겠어, 네 번호 X+1 받을게. 내 번호는 Y야, 너도 확인해
줘.)Client: ACK (알겠어, 네 번호 Y+1 받을게. 연결 성립!)


## 2. 4-way Handshake (TCP 연결 해제 과정)
### 목적:
4-way handshake는 이미 수립된 TCP 연결을 양쪽 모두 정상적으로 종료하기 위한 과정
입니다. 한쪽이 연결을 끊고 싶다고 해서 바로 끊어지는 것이 아니라, 양쪽 모두 "더 이상 보
낼 데이터가 없음"을 확인하고 동의하는 절차를 거칩니다.

### 과정 (Client가 먼저 연결 해제를 요청하는 경우):
#### 1. FIN (Finish - 종료 요청):
- Client → Server: 클라이언트가 데이터 전송을 마치고 연결을 종료하고자 할 때,
TCP 헤더의 FIN 플래그를 1로 설정한 세그먼트를 서버로 보냅니다.
- 클라이언트는 FIN_WAIT_1 상태로 전환됩니다. 이제 클라이언트는 더 이상 데이터를
보내지 않지만, 서버로부터 오는 데이터는 받을 수 있습니다.
#### 2. ACK (Acknowledgement - 종료 요청 확인):
- Server → Client: 서버는 클라이언트로부터 FIN 세그먼트를 받고, 이에 대한 확
인으로 ACK 플래그가 1로 설정된 세그먼트를 클라이언트로 보냅니다.
- 서버는 CLOSE_WAIT 상태로 들어가며, 아직 서버에서 클라이언트로 보내야 할 데이
터가 남아있을 수 있습니다. 이 데이터를 모두 전송할 때까지 기다립니다.
- 클라이언트는 서버로부터 ACK 를 받으면 FIN_WAIT_2 상태로 전환됩니다.
#### 3. FIN (Finish - 최종 종료 요청):
- Server → Client: 서버도 모든 데이터를 전송했고, 연결을 종료할 준비가 되면
FIN 플래그가 1로 설정된 세그먼트를 클라이언트로 보냅니다.
- 서버는 LAST_ACK 상태로 전환되어, 클라이언트로부터 마지막 ACK 를 기다립니다.
#### 4. ACK (Acknowledgement - 최종 확인):
- Client → Server: 클라이언트는 서버로부터 FIN 세그먼트를 받고, 이에 대한 확
인으로 ACK 플래그가 1로 설정된 세그먼트를 서버로 보냅니다.
- 클라이언트는 TIME_WAIT 상태로 들어가 일정 시간 동안 대기합니다. 이 시간 동안
혹시 네트워크상에서 유실되었을지 모르는 마지막 ACK 가 서버에 도달하지 못했을
경우를 대비하고, 같은 포트 번호로 바로 새로운 연결이 생성될 때 발생할 수 있는
문제를 방지합니다. 일정 시간이 지나면 CLOSED 상태로 전환됩니다.
- 서버는 클라이언트로부터 마지막 ACK 를 받으면 CLOSED 상태로 전환되어 연결이
완전히 종료됩니다.

> **요약:** Client: FIN (나 보낼 거 다 보냈어, 이제 끊자.)Server: ACK (알겠어, 잠시만 기다려. 나도 정리할게.)(서버는 남은 데이터 마저 전송...)Server: FIN (나도 이제 다 보냈어, 끊자.)Client: ACK (알겠어. 잠시 후 완전히 끊을게.)

### 왜 4-way 인가?
연결 해제 시, 한쪽(클라이언트)이
FIN 을 보내도 다른 쪽(서버)은 아직 보낼 데이터가 남아 있을 수 있습니다. 따라서 서버는 일
단 클라이언트의 FIN 에 대한 ACK 만 먼저 보내고, 자신의 데이터를 모두 전송한 후에야 비로
소 FIN 을 보낼 수 있습니다. 이 때문에 연결 해제는 4단계로 이루어집니다. CLOSE_WAIT 상
태가 이를 가능하게 합니다.
이 두 가지 핸드셰이크 과정은 TCP가 신뢰성 있는 통신을 제공하는 핵심 메커니즘입니다.

<br>

### RESTful API란 무엇이며, REST의 특징(원칙)은 무엇인가요?
- **API (Application Programming Interface):** 애플리케이션 소프트웨어를 구축하고
통합하기 위한 정의 및 프로토콜 세트입니다. 간단히 말해, 서로 다른 소프트웨어 시스템
이 서로 통신할 수 있도록 하는 접점 또는 계약이라고 할 수 있습니다.
- **REST (REpresentational State Transfer):** "대표 상태 이전"이라고 번역되며, 웹과
같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처 스타일(설계 원칙들의 집
합)입니다. REST는 HTTP 프로토콜을 최대한 활용하여 웹의 장점을 최대한 활용할 수
있도록 설계되었습니다. 2000년에 로이 필딩(Roy Fielding)이 그의 박사 논문에서 제
안했습니다.
- **RESTful API:** REST 아키텍처 스타일의 원칙과 제약 조건을 충실히 따르는 API를 의
미합니다. 즉, REST의 설계 사상을 기반으로 구축된 API를 "RESTful하다"고 표현합니
다.

<br>

### REST의 특징 (6가지 핵심 원칙)
REST 아키텍처 스타일을 따르는 시스템, 즉 "RESTful" 시스템은 다음 6가지 핵심 제약 조
건을 준수해야 합니다.
- #### 1. 클라이언트-서버 (Client-Server Architecture)
    - 클라이언트와 서버가 서로 독립적으로 분리되어야 한다는 원칙입니다.
    - **클라이언트:** 사용자 인터페이스(UI) 및 사용자 경험(UX)에 집중합니다. 서버에 리소스를 요청합니다.
    - **서버:** 비즈니스 로직, 데이터 저장, API 제공 등에 집중합니다. 클라이언트의 요청에 따라 리소스를 응답합니다.
    - **장점:** 역할 분리를 통해 각 부분이 독립적으로 개발, 배포, 확장될 수 있어 유연성과 이식성이 향상됩니다.
- #### 2. 무상태 (Statelessness)
    - 서버가 클라이언트의 상태를 저장하지 않는다는 원칙입니다. 각 요청은 서버가 해당 요청을 이해하고 처리하는 데 필요한 모든 정보를 포함해야 합니다.
    - 즉, 서버는 이전 요청과 현재 요청을 별개로 취급합니다. 세션 정보나 쿠키 등을 서버에 저장하고 관리하지 않습니다. (필요시 클라이언트 측에서 상태를 관리합니다.)
    - **장점:** 서버의 부담을 줄여 가시성, 신뢰성, 확장성을 향상시킵니다. 어떤 서버로 요
청이 가더라도 동일하게 처리할 수 있어 로드 밸런싱에 유리합니다.

- #### 3. 캐시 가능 (Cacheability)
    - 클라이언트는 서버의 응답을 캐시할 수 있어야 한다는 원칙입니다.
    - 서버는 응답을 통해 해당 리소스가 캐시 가능한지, 캐시 기간은 얼마나 되는지 등을 명시해야 합니다. (예: HTTP 헤더의 Cache-Control )
    - **장점:** 클라이언트가 캐시된 데이터를 재사용함으로써 서버와의 상호작용을 줄여 응답 시간을 단축하고, 네트워크 트래픽을 감소시켜 성능과 효율성을 향상시킵니다.

- #### 4. 계층화 시스템 (Layered System)
    - 클라이언트와 서버 사이의 통신은 중간 서버(프록시, 게이트웨이, 로드 밸런서 등)를 가질 수 있는 계층 구조로 구성될 수 있다는 원칙입니다.
    - 클라이언트는 최종 서버에 직접 연결되었는지, 아니면 중간 서버를 통해 연결되었는지 알 필요가 없습니다.
    - **장점:** 시스템의 유연성, 확장성, 보안성을 향상시키고, 레거시 시스템 통합 및 로드 밸런싱 등에 용이합니다.
- #### 5. 균일한 인터페이스 (Uniform Interface)
    - REST 시스템의 가장 핵심적인 원칙 중 하나로, 클라이언트와 서버 간의 인터페이스가 일관되고 예측 가능해야 함을 의미합니다. 이는 시스템 전체 아키텍처를 단순화하고 상호 작용의 가시성을 높입니다. 균일한 인터페이스는 다음 4가지 하위 제약 조건으로 구성됩니다.
        - **자원의 식별 (Identification of resources):** 리소스는 URI(Uniform Resource Identifier)를 통해 고유하게 식별되어야 합니다. URI는 명사 형태를 사용하며, 리소스에 대한 정보를 나타냅니다. (예: /users/123 )
        - **표현을 통한 자원 조작 (Manipulation of resources through representations):** 클라이언트는 리소스의 표현(representation, 예:JSON, XML)을 받아 해당 리소스를 조작합니다. 서버로부터 받은 표현에는 리소스를 수정하거나 삭제하는 데 충분한 정보가 포함되어 있어야 합니다. HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하여 리소스에 대한 작업을 명시합니다.
        - **자기 서술적 메시지 (Self-descriptive messages):** 각 메시지(요청/응답)는 그 자체로 자신을 어떻게 처리해야 하는지에 대한 충분한 정보를 포함해야 합니다. 예를 들어, HTTP 헤더에 Content-Type 을 통해 메시지 본문의 형식을 명시하고, 상태 코드를 통해 요청의 처리 결과를 명확히 전달합니다.
        - **애플리케이션 상태 전이의 엔진으로서의 하이퍼미디어 (HATEOAS: Hypermedia As The Engine Of Application State):** 클라이언트가 서버로부터 받는 응답에는 다음에 수행할 수 있는 작업에 대한 링크(하이퍼미디어)가 포함되어야 합니다. 이를 통해 클라이언트는 동적으로 다음 상태로 전이할 수 있으며, API의 탐색 가능성이 높아집니다.
- #### 6. 주문형 코드 (Code on Demand - 선택 사항)
- 서버가 클라이언트에게 실행 가능한 코드(예: JavaScript)를 전송하여 클라이언트
기능을 확장할 수 있도록 허용하는 원칙입니다.
- 이는 모든 RESTful API에 필수는 아니며, 필요에 따라 선택적으로 사용됩니다.

## RESTful API의 일반적인 특징 및 HTTP 메서드 활용
RESTful API는 위에서 언급된 REST 원칙을 따르면서, 일반적으로 다음과 같은 방식으로
HTTP 프로토콜을 활용합니다.

- 자원(Resource) 중심: 모든 것은 명사 형태의 고유한 URI로 표현되는 자원입니다.
- 행위(Verb)는 HTTP 메서드: 자원에 대한 행위는 HTTP 메서드(GET, POST, PUT,
DELETE, PATCH 등)를 통해 표현됩니다.
    - GET: 리소스 조회 (Read)
    - POST: 리소스 생성 (Create)
    - PUT: 리소스 전체 수정/교체 (Update)
    - PATCH: 리소스 부분 수정 (Update)
    - DELETE: 리소스 삭제 (Delete)
- 표현(Representation): 클라이언트와 서버가 주고받는 리소스의 상태는 JSON,
XML, TEXT 등 다양한 형식으로 표현될 수 있으며, 주로 JSON이 많이 사용됩니다.

이러한 원칙과 특징을 통해 RESTful API는 플랫폼 독립적이고, 확장 가능하며, 유연하고,
유지보수가 용이한 웹 서비스를 구축하는 데 널리 사용되고 있습니다.


<br>

### REST가 나온 주요 이유는 다음과 같습니다:
1. **웹의 성공적인 아키텍처 원칙 정립 및 일반화:**
- 월드 와이드 웹은 엄청난 규모로 확장되면서도 잘 작동하는 분산 시스템의 대표적
인 예시였습니다. 로이 필딩은 웹이 성공할 수 있었던 근본적인 아키텍처 원칙들
(예: HTTP, URI, MIME 타입 등의 표준 활용)을 분석하고, 이를 일반화하여 다른
분산 애플리케이션 설계에도 적용할 수 있는 스타일을 만들고자 했습니다. REST는
바로 이러한 웹의 아키텍처적 특성을 반영한 결과물입니다.
2. **기존 분산 컴퓨팅 기술의 복잡성 및 한계 극복:**
- REST 이전에는 CORBA(Common Object Request Broker Architecture),
RPC(Remote Procedure Call), SOAP(Simple Object Access Protocol)과
같은 기술들이 분산 시스템 간의 통신을 위해 사용되었습니다.
- **복잡성:** 이들 기술은 종종 프로토콜이 복잡하고, 특정 플랫폼이나 프로그래밍 언어
에 종속적인 경우가 많아 구현 및 관리가 어려웠습니다.
- **결합도(Coupling):** 클라이언트와 서버 간의 강한 결합을 유도하여 시스템의 유연
성과 독립적인 진화를 저해하는 경우가 많았습니다.
- **방화벽 통과 문제:** HTTP 이외의 프로토콜을 사용하는 경우 방화벽을 통과하기 어
렵다는 실질적인 문제도 있었습니다.
- REST는 HTTP라는 웹 표준 프로토콜을 그대로 활용함으로써 이러한 복잡성을 줄
이고, 다양한 환경에서의 상호 운용성을 높이고자 했습니다.
3. **느슨한 결합(Loose Coupling)을 통한 유연성 및 확장성 증대:**
- REST는 클라이언트와 서버가 서로의 내부 구현에 대해 알 필요 없이, 잘 정의된 인
터페이스(주로 HTTP와 URI)를 통해 통신하도록 합니다. 이를 통해 클라이언트와
서버는 독립적으로 개발, 배포, 확장될 수 있으며, 시스템 전체의 유연성이 크게 향
상됩니다.
4. **확장성(Scalability) 확보:**
- 무상태(Stateless) 원칙, 캐시 가능(Cacheability) 원칙 등은 서버의 부하를 줄이
고, 네트워크 효율성을 높여 대규모 사용자 요청을 처리할 수 있는 확장성을 제공합
니다. 웹이 수십억 명의 사용자를 지원할 수 있는 것도 이러한 특성 덕분입니다.
5. **단순함(Simplicity)과 가시성(Visibility) 추구:**
- REST는 HTTP 메서드(GET, POST, PUT, DELETE 등)와 URI를 통해 자원과 행
위를 명확하고 직관적으로 표현합니다. 이는 개발자가 API를 이해하고 사용하기 쉽게 만들며, 통신 과정을 파악하기도 용이하게 합니다.
6. **독립적인 진화(Independent Evolvability):**
- 균일한 인터페이스(Uniform Interface) 원칙은 시간이 지남에 따라 클라이언트나
서버의 구현이 변경되더라도 전체 시스템이 안정적으로 작동하도록 지원합니다.


결론적으로 REST는 기존 분산 시스템의 복잡성과 한계를 극복하고, 이미 성공적으로 작동
하고 있던 웹의 아키텍처 원리를 기반으로 하여 **단순하고, 확장 가능하며, 유연하고, 독립적
으로 진화할 수 있는** 분산 시스템을 구축하기 위한 목적으로 등장했습니다. HTTP라는 보편
적인 프로토콜을 활용함으로써 웹 환경에 최적화된 통신 방식을 제시한 것입니다.